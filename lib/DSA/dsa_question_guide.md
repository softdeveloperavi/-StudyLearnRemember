# ðŸ§  DSA Phase-Wise Question List (Easy â†’ Medium â†’ Hard)

> Use this as a **single source of truth** for DSA practice.

---

## ðŸ”° Phase 0: Programming Foundations
### Easy
- Print patterns (stars, numbers)
- Reverse a number
- Check palindrome
- Fibonacci (iterative)

### Medium
- Count digits
- Armstrong number
- Prime check
- GCD / LCM

### Hard
- Fast exponentiation
- Overflow handling problems

---

## Phase 1: Time & Space Complexity
### Easy
- Identify time complexity
- Count loops

### Medium
- Nested loops analysis
- Recursive complexity

### Hard
- Amortized analysis
- Logarithmic recursion

---

## Phase 2: Arrays
### Easy
- Find max/min
- Reverse array
- Check sorted array

### Medium
- Two sum
- Move zeroes
- Kadaneâ€™s algorithm
- Rotate array

### Hard
- Majority element
- Merge intervals
- Trapping rain water
- Maximum product subarray

---

## Phase 3: Strings
### Easy
- Reverse string
- Check palindrome
- Count vowels

### Medium
- Anagram check
- Longest common prefix
- Valid parentheses

### Hard
- Longest substring without repeating characters
- String compression
- Minimum window substring

---

## Phase 4: Searching
### Easy
- Linear search
- Binary search

### Medium
- First/last occurrence
- Search in rotated array

### Hard
- Binary search on answer
- Median of two sorted arrays

---

## Phase 5: Sorting
### Easy
- Bubble sort
- Selection sort

### Medium
- Merge sort
- Quick sort

### Hard
- Count inversions
- Sort colors
- External sorting logic

---

## Phase 6: Recursion
### Easy
- Factorial
- Fibonacci (recursive)

### Medium
- Reverse array recursively
- Power function

### Hard
- Generate subsets
- Recursive palindrome check

---

## Phase 7: Backtracking
### Easy
- Print all subsets

### Medium
- Permutations
- Combination sum

### Hard
- N-Queens
- Sudoku solver
- Rat in a maze

---

## Phase 8: Linked List
### Easy
- Insert node
- Delete node
- Find length

### Medium
- Reverse linked list
- Middle of linked list
- Detect cycle

### Hard
- Merge K sorted lists
- Reverse in groups
- Clone linked list with random pointer

---

## Phase 9: Stack
### Easy
- Stack implementation
- Reverse string using stack

### Medium
- Valid parentheses
- Next greater element

### Hard
- Largest rectangle in histogram
- Stock span problem

---

## Phase 10: Queue & Deque
### Easy
- Queue implementation
- Circular queue

### Medium
- Sliding window maximum
- First non-repeating character

### Hard
- LRU Cache
- Rotten oranges

---

## Phase 11: Hashing
### Easy
- Frequency count
- Two sum

### Medium
- Subarray with sum zero
- Longest consecutive sequence

### Hard
- Count distinct elements in window
- Longest subarray with equal 0s and 1s

---

## Phase 12: Trees
### Easy
- Inorder / Preorder / Postorder
- Height of tree

### Medium
- Level order traversal
- Diameter of tree
- Check balanced tree

### Hard
- Lowest Common Ancestor
- Vertical traversal
- Boundary traversal

---

## Phase 13: Binary Search Tree
### Easy
- Search in BST
- Insert node

### Medium
- Validate BST
- Floor / Ceil

### Hard
- Kth smallest element
- BST to sorted DLL

---

## Phase 14: Heap / Priority Queue
### Easy
- Heap implementation
- K largest elements

### Medium
- Merge K sorted arrays
- Median in stream

### Hard
- Sliding window median
- Reorganize string

---

## Phase 15: Graphs (Core)
### Easy
- BFS
- DFS

### Medium
- Cycle detection
- Number of islands

### Hard
- Topological sort
- Bipartite graph check

---

## Phase 16: Graphs (Advanced)
### Easy
- Shortest path in unweighted graph

### Medium
- Dijkstra
- Union-Find basics

### Hard
- Kruskalâ€™s MST
- Bellman-Ford
- Floyd-Warshall

---

## Phase 17: Greedy
### Easy
- Activity selection

### Medium
- Job sequencing
- Fractional knapsack

### Hard
- Minimum platforms
- Gas station problem

---

## Phase 18: Dynamic Programming
### Easy
- Fibonacci (DP)
- Climbing stairs

### Medium
- Knapsack
- Longest common subsequence
- Coin change

### Hard
- Matrix chain multiplication
- Palindromic partitioning
- DP on trees

---

## Phase 19: Trie
### Easy
- Insert & search words

### Medium
- Prefix search
- Auto-complete

### Hard
- Maximum XOR
- Word search II

---

## Phase 20: Segment Tree
### Easy
- Range sum query

### Medium
- Range minimum query

### Hard
- Lazy propagation
- Dynamic segment tree

---

## Phase 21: Fenwick Tree
### Easy
- Prefix sum query

### Medium
- Range update

### Hard
- Inversion count using BIT

---

## Phase 22: Advanced Strings
### Easy
- Pattern matching basics

### Medium
- KMP algorithm

### Hard
- Manacherâ€™s algorithm
- Z-algorithm problems

---

## Phase 23: Bit Manipulation
### Easy
- Check odd/even
- Set / clear bit

### Medium
- Single number
- Count set bits

### Hard
- Subset generation
- Bitmask DP

---

## Phase 24: Math Algorithms
### Easy
- GCD / LCM
- Prime check

### Medium
- Sieve of Eratosthenes
- Modular exponentiation

### Hard
- Chinese remainder theorem
- Combinatorics with mod

---

## Phase 25: Advanced Patterns
### Easy
- Sliding window fixed size

### Medium
- Variable sliding window

### Hard
- Meet in the middle
- Moâ€™s algorithm

---

## Phase 26: Competitive Programming
### Medium
- Fast I/O handling
- Constraints optimization

### Hard
- Multiple test case optimization

---

## Phase 27: Interview Practice
### Medium
- Timed mixed questions

### Hard
- Mock interviews
- Explain approach + complexity

---

## âœ… Final Advice
> Donâ€™t rush to hard problems.  
> **Easy â†’ Medium â†’ Hard is the winning path.**
